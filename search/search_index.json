{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#causalprog","title":"causalprog","text":"<p>A Python package for causal modelling and inference with stochastic causal programming</p> <p>This project is developed in collaboration with the Centre for Advanced Research Computing, University College London.</p>"},{"location":"#about","title":"About","text":""},{"location":"#project-team","title":"Project team","text":"<ul> <li>Ricardo Silva (rbas-ucl)</li> <li>Jialin Yu (jialin-yu)</li> <li>Will Graham (willGraham01)</li> <li>Matthew Scroggs (mscroggs)</li> <li>Matt Graham (matt-graham)</li> </ul>"},{"location":"#research-software-engineering-contact","title":"Research software engineering contact","text":"<p>Centre for Advanced Research Computing, University College London (arc.collaborations@ucl.ac.uk)</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<p><code>causalprog</code> requires Python 3.11\u20133.13.</p>"},{"location":"#installation","title":"Installation","text":"<p>We recommend installing in a project specific virtual environment. To install the latest development version of <code>causalprog</code> using <code>pip</code> in the currently active environment run</p> <pre><code>pip install git+https://github.com/UCL/causalprog.git\n</code></pre> <p>Alternatively create a local clone of the repository with</p> <pre><code>git clone https://github.com/UCL/causalprog.git\n</code></pre> <p>and then install in editable mode by running</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"#running-tests","title":"Running tests","text":"<p>Tests can be run across all compatible Python versions in isolated environments using <code>tox</code> by running</p> <pre><code>tox\n</code></pre> <p>To run tests manually in a Python environment with <code>pytest</code> installed run</p> <pre><code>pytest tests\n</code></pre> <p>again from the root of the repository.</p>"},{"location":"#building-documentation","title":"Building documentation","text":"<p>The MkDocs HTML documentation can be built locally by running</p> <pre><code>tox -e docs\n</code></pre> <p>from the root of the repository. The built documentation will be written to <code>site</code>.</p> <p>Alternatively to build and preview the documentation locally, in a Python environment with the optional <code>docs</code> dependencies installed, run</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>This work was funded by Engineering and Physical Sciences Research Council (EPSRC).</p>"},{"location":"LICENSE/","title":"License","text":""},{"location":"LICENSE/#mit-license","title":"MIT License","text":"<p>Copyright (c) 2025 University College London</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"api/","title":"API reference","text":"<p>causalprog package.</p>"},{"location":"api/#causalprog.algorithms","title":"<code>algorithms</code>","text":"<p>Algorithms.</p>"},{"location":"api/#causalprog.algorithms.expectation","title":"<code>expectation</code>","text":"<p>Algorithms for estimating the expectation and standard deviation.</p>"},{"location":"api/#causalprog.algorithms.expectation.expectation","title":"<code>expectation(graph, outcome_node_label, samples, *, rng_key)</code>","text":"<p>Estimate the expectation of a graph.</p> Source code in <code>src/causalprog/algorithms/expectation.py</code> <pre><code>def expectation(\n    graph: Graph,\n    outcome_node_label: str,\n    samples: int,\n    *,\n    rng_key: jax.Array,\n) -&gt; float:\n    \"\"\"Estimate the expectation of a graph.\"\"\"\n    return sample(graph, outcome_node_label, samples, rng_key=rng_key).mean()\n</code></pre>"},{"location":"api/#causalprog.algorithms.expectation.sample","title":"<code>sample(graph, outcome_node_label, samples, *, rng_key)</code>","text":"<p>Sample data from a graph.</p> Source code in <code>src/causalprog/algorithms/expectation.py</code> <pre><code>def sample(\n    graph: Graph,\n    outcome_node_label: str,\n    samples: int,\n    *,\n    rng_key: jax.Array,\n) -&gt; npt.NDArray[float]:\n    \"\"\"Sample data from a graph.\"\"\"\n    if outcome_node_label is None:\n        outcome_node_label = graph.outcome.label\n\n    nodes = graph.roots_down_to_outcome(outcome_node_label)\n\n    values: dict[str, npt.NDArray[float]] = {}\n    keys = jax.random.split(rng_key, len(nodes))\n\n    for node, key in zip(nodes, keys, strict=False):\n        values[node.label] = node.sample(values, samples, rng_key=key)\n    return values[outcome_node_label]\n</code></pre>"},{"location":"api/#causalprog.algorithms.expectation.standard_deviation","title":"<code>standard_deviation(graph, outcome_node_label, samples, *, rng_key)</code>","text":"<p>Estimate the standard deviation of a graph.</p> Source code in <code>src/causalprog/algorithms/expectation.py</code> <pre><code>def standard_deviation(\n    graph: Graph,\n    outcome_node_label: str,\n    samples: int,\n    *,\n    rng_key: jax.Array,\n) -&gt; float:\n    \"\"\"Estimate the standard deviation of a graph.\"\"\"\n    return sample(graph, outcome_node_label, samples, rng_key=rng_key).std()\n</code></pre>"},{"location":"api/#causalprog.backend","title":"<code>backend</code>","text":"<p>Helper functionality for incorporating different backends.</p>"},{"location":"api/#causalprog.causal_problem","title":"<code>causal_problem</code>","text":"<p>Extension of the Graph class providing features for solving causal problems.</p>"},{"location":"api/#causalprog.causal_problem.CausalProblem","title":"<code>CausalProblem</code>","text":"<p>               Bases: <code>Labelled</code></p> <p>Container class for handling a causal problem.</p> <p>A causal problem https://github-pages.ucl.ac.uk/causalprog/theory/mathematical-context/ requires an underlying <code>Graph</code> to describe the relationships between the random variables and parameters, plus a causal estimand and list of (data) constraints. Structural constraints are handled by imposing restrictions on forms of the random variables and constraints directly.</p> <p>A <code>CausalProblem</code> instance brings together these components, providing a container for a causal problem that can be given inputs like empirical data, a solver tolerance, etc, and will provide (estimates of) the bounds for the causal estimand.</p> <ul> <li>The <code>.graph</code> attribute stores the underlying <code>Graph</code> object.</li> <li>The <code>.causal_estimand</code> method evaluates the causal estimand, given values for     the parameters.</li> <li>The <code>.constraints</code> method evaluates the (vector-valued) constraints, given     values for the parameters.</li> </ul> <p>The user must specify each of the above before a <code>CausalProblem</code> can be solved. The primary way for this to be done is to construct or load the corresponding <code>Graph</code>, and provide it by setting the <code>CausalProblem.graph</code> attribute directly. Then, <code>set_causal_estimand</code> and <code>set_constraints</code> can be used to provide the causal estimand and constraints functions, in terms of the random variables. The <code>CausalProblem</code> instance will handle turning them into functions of the parameter values under the hood. Initial parameter values (for the purposes of solving) can be provided to the solver method directly or set beforehand via <code>set_parameters</code>. It should never be necessary for the user to interact with, or provide, a vector of parameters (as this is taken care of under the hood).</p> Source code in <code>src/causalprog/causal_problem.py</code> <pre><code>class CausalProblem(Labelled):\n    \"\"\"\n    Container class for handling a causal problem.\n\n    A causal problem &lt;https://github-pages.ucl.ac.uk/causalprog/theory/mathematical-context/&gt;\n    requires an underlying ``Graph`` to describe the relationships between the random\n    variables and parameters, plus a causal estimand and list of (data) constraints.\n    Structural constraints are handled by imposing restrictions on forms of the random\n    variables and constraints directly.\n\n    A ``CausalProblem`` instance brings together these components, providing a container\n    for a causal problem that can be given inputs like empirical data, a solver\n    tolerance, etc, and will provide (estimates of) the bounds for the causal estimand.\n\n    - The ``.graph`` attribute stores the underlying ``Graph`` object.\n    - The ``.causal_estimand`` method evaluates the causal estimand, given values for\n        the parameters.\n    - The ``.constraints`` method evaluates the (vector-valued) constraints, given\n        values for the parameters.\n\n    The user must specify each of the above before a ``CausalProblem`` can be solved.\n    The primary way for this to be done is to construct or load the corresponding\n    ``Graph``, and provide it by setting the ``CausalProblem.graph`` attribute directly.\n    Then, `set_causal_estimand` and `set_constraints` can be used to provide the causal\n    estimand and constraints functions, in terms of the random variables. The\n    ``CausalProblem`` instance will handle turning them into functions of the parameter\n    values under the hood. Initial parameter values (for the purposes of solving) can be\n    provided to the solver method directly or set beforehand via ``set_parameters``. It\n    should never be necessary for the user to interact with, or provide, a vector of\n    parameters (as this is taken care of under the hood).\n    \"\"\"\n\n    _graph: Graph | None\n    _sigma: CausalEstimand\n    _sigma_mapping: dict[str, Node]\n    _constraints: Constraints\n    _constraints_mapping: dict[str, Node]\n\n    @property\n    def graph(self) -&gt; Graph:\n        \"\"\"Graph defining the structure of the `CausalProblem`.\"\"\"\n        if self._graph is None:\n            msg = f\"No graph set for {self.label}.\"\n            raise ValueError(msg)\n        return self._graph\n\n    @graph.setter\n    def graph(self, new_graph: Graph) -&gt; None:\n        if not isinstance(new_graph, Graph):\n            msg = f\"{self.label}.graph must be a Graph instance.\"\n            raise TypeError(msg)\n        self._graph = new_graph\n\n    @property\n    def parameter_values(self) -&gt; dict[str, float]:\n        \"\"\"Dictionary mapping parameter labels to their (current) values.\"\"\"\n        return self._parameter_vector_to_dict(self.parameter_vector)\n\n    @property\n    def parameter_vector(self) -&gt; jax.Array:\n        \"\"\"Returns the (current) vector of parameter values.\"\"\"\n        return jnp.array(\n            tuple(\n                node.value if node.value is not None else float(\"NaN\")\n                for node in self.graph.parameter_nodes\n            ),\n            ndmin=1,\n        )\n\n    def __init__(\n        self,\n        graph: Graph | None = None,\n        *,\n        label: str = \"CausalProblem\",\n    ) -&gt; None:\n        \"\"\"Set up a new CausalProblem.\"\"\"\n        super().__init__(label=label)\n\n        self._graph = graph\n\n        self._sigma = raises(\n            NotImplementedError(f\"Causal estimand not set for {self.label}.\")\n        )\n        self._sigma_mapping = {}\n\n    def _parameter_vector_to_dict(\n        self, parameter_vector: jax.Array\n    ) -&gt; dict[str, float]:\n        \"\"\"\n        Convert a parameter vector to a dictionary mapping labels to parameter values.\n\n        Convention is that a vector of parameter values contains values in the same\n        order as self.graph.parameter_nodes.\n        \"\"\"\n        # Avoid recomputing the parameter node tuple every time.\n        pn = self.graph.parameter_nodes\n        return {pn[i].label: value for i, value in enumerate(parameter_vector)}\n\n    def _set_parameters_via_vector(self, parameter_vector: jax.Array | None) -&gt; None:\n        \"\"\"\n        Shorthand to set parameter node values from a parameter vector.\n\n        No intended for frontend use - primary use will be internal when running\n        optimisation methods over the CausalProblem, when we need to treat the\n        parameters as a vector or array of function inputs.\n        \"\"\"\n        self.graph.set_parameters(**self._parameter_vector_to_dict(parameter_vector))\n\n    def set_parameter_values(self, **parameter_values: float | None) -&gt; None:\n        \"\"\"\n        Set (initial) parameter values for this CausalProblem.\n\n        See ``Graph.set_parameters`` for input details.\n        \"\"\"\n        self.graph.set_parameters(**parameter_values)\n\n    def set_causal_estimand(\n        self,\n        sigma: CausalEstimand,\n        rvs_to_nodes: dict[str, str] | None = None,\n        graph_argument: str | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Set the Causal Estimand for this problem.\n\n        `sigma` should be a callable object that defines the Causal Estimand of\n        interest, in terms of the random variables of to the problem. The\n        random variables are in turn represented by `Node`s, with this association being\n        recorded in the `rv_to_nodes` dictionary.\n\n        The `causal_estimand` method of the instance will be usable once this method\n        completes.\n\n        Args:\n            sigma (CausalEstimand): Callable object that evaluates the causal estimand\n                of interest for this `CausalProblem`, in terms of the random variables,\n                which are the arguments to this callable. `sigma`s with additional\n                arguments are not currently supported.\n            rvs_to_nodes (dict[str, str]): Mapping of random variable (argument) names\n                of `sigma` to the labels of the corresponding `Node`s representing the\n                random variables. Argument names that match their corresponding `Node`\n                label can be omitted.\n            graph_argument (str): Argument to `sigma` that should be replaced with\n                `self.graph`. This argument is only temporary, as we are currently\n                limited to the syntax `expectation(Graph, Node)` rather than just\n                `expectation(Node)`. It will be removed in the future when methods like\n                `expectation` can be called solely on `Node` objects.\n\n        \"\"\"\n        self._sigma = sigma\n        self._sigma_mapping = {}\n\n        if rvs_to_nodes is None:\n            rvs_to_nodes = {}\n        sigma_args = signature(sigma).parameters\n\n        for rv_name, node_label in rvs_to_nodes.items():\n            if rv_name not in sigma_args:\n                msg = f\"{rv_name} is not a parameter to causal estimand provided.\"\n                raise ValueError(msg)\n            self._sigma_mapping[rv_name] = self.graph.get_node(node_label)\n\n        # Any unaccounted-for RV arguments to sigma are assumed to match\n        # the label of the corresponding node.\n        args_not_used = set(sigma_args.keys()) - set(self._sigma_mapping.keys())\n\n        ## Temporary hack to ensure that we can use expectation(graph, X) syntax.\n        if graph_argument:\n            self._sigma_mapping[graph_argument] = self.graph\n            args_not_used -= {graph_argument}\n        ## END HACK\n        for arg in args_not_used:\n            self._sigma_mapping[arg] = self.graph.get_node(arg)\n\n    def causal_estimand(self, p: jax.Array) -&gt; float:\n        \"\"\"\n        Evaluate the Causal Estimand at parameter vector `p`.\n\n        Args:\n            p (jax.Array): Vector of parameter values to evaluate at.\n\n        \"\"\"\n        # Set parameter nodes to their new values.\n        self._set_parameters_via_vector(p)\n        # Call stored function with transformed arguments.\n        return self._sigma(**self._sigma_mapping)\n</code></pre>"},{"location":"api/#causalprog.causal_problem.CausalProblem.graph","title":"<code>graph</code>  <code>property</code> <code>writable</code>","text":"<p>Graph defining the structure of the <code>CausalProblem</code>.</p>"},{"location":"api/#causalprog.causal_problem.CausalProblem.parameter_values","title":"<code>parameter_values</code>  <code>property</code>","text":"<p>Dictionary mapping parameter labels to their (current) values.</p>"},{"location":"api/#causalprog.causal_problem.CausalProblem.parameter_vector","title":"<code>parameter_vector</code>  <code>property</code>","text":"<p>Returns the (current) vector of parameter values.</p>"},{"location":"api/#causalprog.causal_problem.CausalProblem.__init__","title":"<code>__init__(graph=None, *, label='CausalProblem')</code>","text":"<p>Set up a new CausalProblem.</p> Source code in <code>src/causalprog/causal_problem.py</code> <pre><code>def __init__(\n    self,\n    graph: Graph | None = None,\n    *,\n    label: str = \"CausalProblem\",\n) -&gt; None:\n    \"\"\"Set up a new CausalProblem.\"\"\"\n    super().__init__(label=label)\n\n    self._graph = graph\n\n    self._sigma = raises(\n        NotImplementedError(f\"Causal estimand not set for {self.label}.\")\n    )\n    self._sigma_mapping = {}\n</code></pre>"},{"location":"api/#causalprog.causal_problem.CausalProblem.causal_estimand","title":"<code>causal_estimand(p)</code>","text":"<p>Evaluate the Causal Estimand at parameter vector <code>p</code>.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>Array</code> <p>Vector of parameter values to evaluate at.</p> required Source code in <code>src/causalprog/causal_problem.py</code> <pre><code>def causal_estimand(self, p: jax.Array) -&gt; float:\n    \"\"\"\n    Evaluate the Causal Estimand at parameter vector `p`.\n\n    Args:\n        p (jax.Array): Vector of parameter values to evaluate at.\n\n    \"\"\"\n    # Set parameter nodes to their new values.\n    self._set_parameters_via_vector(p)\n    # Call stored function with transformed arguments.\n    return self._sigma(**self._sigma_mapping)\n</code></pre>"},{"location":"api/#causalprog.causal_problem.CausalProblem.set_causal_estimand","title":"<code>set_causal_estimand(sigma, rvs_to_nodes=None, graph_argument=None)</code>","text":"<p>Set the Causal Estimand for this problem.</p> <p><code>sigma</code> should be a callable object that defines the Causal Estimand of interest, in terms of the random variables of to the problem. The random variables are in turn represented by <code>Node</code>s, with this association being recorded in the <code>rv_to_nodes</code> dictionary.</p> <p>The <code>causal_estimand</code> method of the instance will be usable once this method completes.</p> <p>Parameters:</p> Name Type Description Default <code>sigma</code> <code>CausalEstimand</code> <p>Callable object that evaluates the causal estimand of interest for this <code>CausalProblem</code>, in terms of the random variables, which are the arguments to this callable. <code>sigma</code>s with additional arguments are not currently supported.</p> required <code>rvs_to_nodes</code> <code>dict[str, str]</code> <p>Mapping of random variable (argument) names of <code>sigma</code> to the labels of the corresponding <code>Node</code>s representing the random variables. Argument names that match their corresponding <code>Node</code> label can be omitted.</p> <code>None</code> <code>graph_argument</code> <code>str</code> <p>Argument to <code>sigma</code> that should be replaced with <code>self.graph</code>. This argument is only temporary, as we are currently limited to the syntax <code>expectation(Graph, Node)</code> rather than just <code>expectation(Node)</code>. It will be removed in the future when methods like <code>expectation</code> can be called solely on <code>Node</code> objects.</p> <code>None</code> Source code in <code>src/causalprog/causal_problem.py</code> <pre><code>def set_causal_estimand(\n    self,\n    sigma: CausalEstimand,\n    rvs_to_nodes: dict[str, str] | None = None,\n    graph_argument: str | None = None,\n) -&gt; None:\n    \"\"\"\n    Set the Causal Estimand for this problem.\n\n    `sigma` should be a callable object that defines the Causal Estimand of\n    interest, in terms of the random variables of to the problem. The\n    random variables are in turn represented by `Node`s, with this association being\n    recorded in the `rv_to_nodes` dictionary.\n\n    The `causal_estimand` method of the instance will be usable once this method\n    completes.\n\n    Args:\n        sigma (CausalEstimand): Callable object that evaluates the causal estimand\n            of interest for this `CausalProblem`, in terms of the random variables,\n            which are the arguments to this callable. `sigma`s with additional\n            arguments are not currently supported.\n        rvs_to_nodes (dict[str, str]): Mapping of random variable (argument) names\n            of `sigma` to the labels of the corresponding `Node`s representing the\n            random variables. Argument names that match their corresponding `Node`\n            label can be omitted.\n        graph_argument (str): Argument to `sigma` that should be replaced with\n            `self.graph`. This argument is only temporary, as we are currently\n            limited to the syntax `expectation(Graph, Node)` rather than just\n            `expectation(Node)`. It will be removed in the future when methods like\n            `expectation` can be called solely on `Node` objects.\n\n    \"\"\"\n    self._sigma = sigma\n    self._sigma_mapping = {}\n\n    if rvs_to_nodes is None:\n        rvs_to_nodes = {}\n    sigma_args = signature(sigma).parameters\n\n    for rv_name, node_label in rvs_to_nodes.items():\n        if rv_name not in sigma_args:\n            msg = f\"{rv_name} is not a parameter to causal estimand provided.\"\n            raise ValueError(msg)\n        self._sigma_mapping[rv_name] = self.graph.get_node(node_label)\n\n    # Any unaccounted-for RV arguments to sigma are assumed to match\n    # the label of the corresponding node.\n    args_not_used = set(sigma_args.keys()) - set(self._sigma_mapping.keys())\n\n    ## Temporary hack to ensure that we can use expectation(graph, X) syntax.\n    if graph_argument:\n        self._sigma_mapping[graph_argument] = self.graph\n        args_not_used -= {graph_argument}\n    ## END HACK\n    for arg in args_not_used:\n        self._sigma_mapping[arg] = self.graph.get_node(arg)\n</code></pre>"},{"location":"api/#causalprog.causal_problem.CausalProblem.set_parameter_values","title":"<code>set_parameter_values(**parameter_values)</code>","text":"<p>Set (initial) parameter values for this CausalProblem.</p> <p>See <code>Graph.set_parameters</code> for input details.</p> Source code in <code>src/causalprog/causal_problem.py</code> <pre><code>def set_parameter_values(self, **parameter_values: float | None) -&gt; None:\n    \"\"\"\n    Set (initial) parameter values for this CausalProblem.\n\n    See ``Graph.set_parameters`` for input details.\n    \"\"\"\n    self.graph.set_parameters(**parameter_values)\n</code></pre>"},{"location":"api/#causalprog.causal_problem.raises","title":"<code>raises(exception)</code>","text":"<p>Create a callable that raises <code>exception</code> when called.</p> Source code in <code>src/causalprog/causal_problem.py</code> <pre><code>def raises(exception: Exception) -&gt; Callable[[], float]:\n    \"\"\"Create a callable that raises ``exception`` when called.\"\"\"\n\n    def _inner() -&gt; float:\n        raise exception\n\n    return _inner\n</code></pre>"},{"location":"api/#causalprog.distribution","title":"<code>distribution</code>","text":"<p>Distribution.</p>"},{"location":"api/#causalprog.distribution.base","title":"<code>base</code>","text":"<p>Base class for backend-agnostic distributions.</p>"},{"location":"api/#causalprog.distribution.base.Distribution","title":"<code>Distribution</code>","text":"<p>               Bases: <code>Generic[SupportsSampling]</code>, <code>Labelled</code></p> <p>A (backend-agnostic) distribution that can be sampled from.</p> Source code in <code>src/causalprog/distribution/base.py</code> <pre><code>class Distribution(Generic[SupportsSampling], Labelled):\n    \"\"\"A (backend-agnostic) distribution that can be sampled from.\"\"\"\n\n    _dist: SupportsSampling\n    _backend_translator: SampleTranslator\n\n    @property\n    def _sample(self) -&gt; Callable[..., ArrayLike]:\n        \"\"\"Method for drawing samples from the backend object.\"\"\"\n        return getattr(self._dist, self._backend_translator.backend_method)\n\n    def __init__(\n        self,\n        backend_distribution: SupportsSampling,\n        backend_translator: SampleTranslator | None = None,\n        *,\n        label: str = \"Distribution\",\n    ) -&gt; None:\n        \"\"\"\n        Create a new Distribution.\n\n        Args:\n            backend_distribution (SupportsSampling): Backend object that supports\n                drawing random samples.\n            backend_translator (SampleTranslator): Translator object mapping backend\n                sampling function to frontend arguments.\n\n        \"\"\"\n        super().__init__(label=label)\n\n        self._dist = backend_distribution\n\n        # Setup sampling calls, and perform one-time check for compatibility\n        self._backend_translator = (\n            backend_translator if backend_translator is not None else SampleTranslator()\n        )\n        self._backend_translator.validate_compatible(backend_distribution)\n\n    def get_dist(self) -&gt; SupportsSampling:\n        \"\"\"Access to the backend distribution.\"\"\"\n        return self._dist\n\n    def sample(self, rng_key: SupportsRNG, sample_shape: ArrayLike = ()) -&gt; ArrayLike:\n        \"\"\"\n        Draw samples from the distribution.\n\n        Args:\n            rng_key (SupportsRNG): Key or seed object to generate random samples.\n            sample_shape (ArrayLike): Shape of samples to draw.\n\n        Returns:\n            ArrayLike: Randomly-drawn samples from the distribution.\n\n        \"\"\"\n        args_to_backend = self._backend_translator.translate_args(\n            rng_key=rng_key, sample_shape=sample_shape\n        )\n        return self._sample(**args_to_backend)\n</code></pre>"},{"location":"api/#causalprog.distribution.base.Distribution.__init__","title":"<code>__init__(backend_distribution, backend_translator=None, *, label='Distribution')</code>","text":"<p>Create a new Distribution.</p> <p>Parameters:</p> Name Type Description Default <code>backend_distribution</code> <code>SupportsSampling</code> <p>Backend object that supports drawing random samples.</p> required <code>backend_translator</code> <code>SampleTranslator</code> <p>Translator object mapping backend sampling function to frontend arguments.</p> <code>None</code> Source code in <code>src/causalprog/distribution/base.py</code> <pre><code>def __init__(\n    self,\n    backend_distribution: SupportsSampling,\n    backend_translator: SampleTranslator | None = None,\n    *,\n    label: str = \"Distribution\",\n) -&gt; None:\n    \"\"\"\n    Create a new Distribution.\n\n    Args:\n        backend_distribution (SupportsSampling): Backend object that supports\n            drawing random samples.\n        backend_translator (SampleTranslator): Translator object mapping backend\n            sampling function to frontend arguments.\n\n    \"\"\"\n    super().__init__(label=label)\n\n    self._dist = backend_distribution\n\n    # Setup sampling calls, and perform one-time check for compatibility\n    self._backend_translator = (\n        backend_translator if backend_translator is not None else SampleTranslator()\n    )\n    self._backend_translator.validate_compatible(backend_distribution)\n</code></pre>"},{"location":"api/#causalprog.distribution.base.Distribution.get_dist","title":"<code>get_dist()</code>","text":"<p>Access to the backend distribution.</p> Source code in <code>src/causalprog/distribution/base.py</code> <pre><code>def get_dist(self) -&gt; SupportsSampling:\n    \"\"\"Access to the backend distribution.\"\"\"\n    return self._dist\n</code></pre>"},{"location":"api/#causalprog.distribution.base.Distribution.sample","title":"<code>sample(rng_key, sample_shape=())</code>","text":"<p>Draw samples from the distribution.</p> <p>Parameters:</p> Name Type Description Default <code>rng_key</code> <code>SupportsRNG</code> <p>Key or seed object to generate random samples.</p> required <code>sample_shape</code> <code>ArrayLike</code> <p>Shape of samples to draw.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>ArrayLike</code> <code>ArrayLike</code> <p>Randomly-drawn samples from the distribution.</p> Source code in <code>src/causalprog/distribution/base.py</code> <pre><code>def sample(self, rng_key: SupportsRNG, sample_shape: ArrayLike = ()) -&gt; ArrayLike:\n    \"\"\"\n    Draw samples from the distribution.\n\n    Args:\n        rng_key (SupportsRNG): Key or seed object to generate random samples.\n        sample_shape (ArrayLike): Shape of samples to draw.\n\n    Returns:\n        ArrayLike: Randomly-drawn samples from the distribution.\n\n    \"\"\"\n    args_to_backend = self._backend_translator.translate_args(\n        rng_key=rng_key, sample_shape=sample_shape\n    )\n    return self._sample(**args_to_backend)\n</code></pre>"},{"location":"api/#causalprog.distribution.base.SampleTranslator","title":"<code>SampleTranslator</code>","text":"<p>               Bases: <code>Translator</code></p> <p>Translate methods for sampling from distributions.</p> <p>The <code>Distribution</code> class provides a <code>sample</code> method, that takes <code>rng_key</code> and <code>sample_shape</code> as its arguments. Instances of this class transform the these arguments to those that a backend distribution expects.</p> Source code in <code>src/causalprog/distribution/base.py</code> <pre><code>class SampleTranslator(Translator):\n    \"\"\"\n    Translate methods for sampling from distributions.\n\n    The ``Distribution`` class provides a ``sample`` method, that takes ``rng_key`` and\n    ``sample_shape`` as its arguments. Instances of this class transform the these\n    arguments to those that a backend distribution expects.\n    \"\"\"\n\n    @property\n    def _frontend_method(self) -&gt; str:\n        return \"sample\"\n\n    @property\n    def compulsory_frontend_args(self) -&gt; set[str]:\n        \"\"\"Arguments that are required by the frontend function.\"\"\"\n        return {\"rng_key\", \"sample_shape\"}\n</code></pre>"},{"location":"api/#causalprog.distribution.base.SampleTranslator.compulsory_frontend_args","title":"<code>compulsory_frontend_args</code>  <code>property</code>","text":"<p>Arguments that are required by the frontend function.</p>"},{"location":"api/#causalprog.distribution.family","title":"<code>family</code>","text":"<p>Parametrised groups of <code>Distribution</code>s.</p>"},{"location":"api/#causalprog.distribution.family.DistributionFamily","title":"<code>DistributionFamily</code>","text":"<p>               Bases: <code>Generic[CreatesDistribution]</code>, <code>Labelled</code></p> <p>A family of <code>Distributions</code>, that share the same parameters.</p> <p>A <code>DistributionFamily</code> is essentially a <code>Distribution</code> that has not yet had its parameter values explicitly specified. Explicit values for the parameters can be passed to a <code>DistributionFamily</code>'s <code>construct</code> method, which will then proceed to construct a <code>Distribution</code> with those parameter values.</p> <p>As an explicit example, the (possibly multivariate) normal distribution is parametrised by two quantities - the (vector of) mean values \\(\\mu\\) and covariates \\(\\Sigma\\). A <code>DistributionFamily</code> represents this general \\(\\mathcal{N}(\\mu, \\Sigma)\\) parametrised form, however without explicit \\(\\mu\\) and \\(\\Sigma\\) values we cannot perform operations like drawing samples. Specifying, for example, \\(\\mu = 0\\) and \\(\\Sigma = 1\\) by invoking <code>.construct(0., 1.)</code> will return a <code>Distribution</code> instance representing \\(\\mathcal{N}(0., 1.)\\), which can then have samples drawn from it.</p> Source code in <code>src/causalprog/distribution/family.py</code> <pre><code>class DistributionFamily(Generic[CreatesDistribution], Labelled):\n    r\"\"\"\n    A family of ``Distributions``, that share the same parameters.\n\n    A ``DistributionFamily`` is essentially a ``Distribution`` that has not yet had its\n    parameter values explicitly specified. Explicit values for the parameters can be\n    passed to a ``DistributionFamily``'s ``construct`` method, which will then proceed\n    to construct a ``Distribution`` with those parameter values.\n\n    As an explicit example, the (possibly multivariate) normal distribution is\n    parametrised by two quantities - the (vector of) mean values $\\mu$ and covariates\n    $\\Sigma$. A ``DistributionFamily`` represents this general\n    $\\mathcal{N}(\\mu, \\Sigma)$ parametrised form, however without explicit $\\mu$ and\n    $\\Sigma$ values we cannot perform operations like drawing samples. Specifying, for\n    example, $\\mu = 0$ and $\\Sigma = 1$ by invoking ``.construct(0., 1.)`` will return a\n    ``Distribution`` instance representing $\\mathcal{N}(0., 1.)$, which can then have\n    samples drawn from it.\n    \"\"\"\n\n    _family: CreatesDistribution\n    _family_translator: Translator | None\n\n    @property\n    def _member(self) -&gt; Callable[..., Distribution]:\n        \"\"\"Constructor method for family members, given parameters.\"\"\"\n        return lambda **parameters: Distribution(\n            self._family(**parameters),\n            backend_translator=self._family_translator,\n        )\n\n    def __init__(\n        self,\n        backend_family: CreatesDistribution,\n        backend_translator: Translator | None = None,\n        *,\n        family_name: str = \"DistributionFamily\",\n    ) -&gt; None:\n        \"\"\"\n        Create a new family of distributions.\n\n        Args:\n            backend_family (CreatesDistribution): Backend callable that assembles the\n                distribution, given explicit parameter values. Currently, this callable\n                can only accept the parameters as a sequence of positional arguments.\n            backend_translator (Translator): ``Translator`` instance that to be\n                passed to the ``Distribution`` constructor.\n\n        \"\"\"\n        super().__init__(label=family_name)\n\n        self._family = backend_family\n        self._family_translator = backend_translator\n\n    def construct(self, **parameters: ArrayLike) -&gt; Distribution:\n        \"\"\"\n        Create a distribution from an explicit set of parameters.\n\n        Args:\n            **parameters (ArrayLike): Parameters that define a member of this family,\n                passed as sequential arguments.\n\n        \"\"\"\n        return self._member(**parameters)\n</code></pre>"},{"location":"api/#causalprog.distribution.family.DistributionFamily.__init__","title":"<code>__init__(backend_family, backend_translator=None, *, family_name='DistributionFamily')</code>","text":"<p>Create a new family of distributions.</p> <p>Parameters:</p> Name Type Description Default <code>backend_family</code> <code>CreatesDistribution</code> <p>Backend callable that assembles the distribution, given explicit parameter values. Currently, this callable can only accept the parameters as a sequence of positional arguments.</p> required <code>backend_translator</code> <code>Translator</code> <p><code>Translator</code> instance that to be passed to the <code>Distribution</code> constructor.</p> <code>None</code> Source code in <code>src/causalprog/distribution/family.py</code> <pre><code>def __init__(\n    self,\n    backend_family: CreatesDistribution,\n    backend_translator: Translator | None = None,\n    *,\n    family_name: str = \"DistributionFamily\",\n) -&gt; None:\n    \"\"\"\n    Create a new family of distributions.\n\n    Args:\n        backend_family (CreatesDistribution): Backend callable that assembles the\n            distribution, given explicit parameter values. Currently, this callable\n            can only accept the parameters as a sequence of positional arguments.\n        backend_translator (Translator): ``Translator`` instance that to be\n            passed to the ``Distribution`` constructor.\n\n    \"\"\"\n    super().__init__(label=family_name)\n\n    self._family = backend_family\n    self._family_translator = backend_translator\n</code></pre>"},{"location":"api/#causalprog.distribution.family.DistributionFamily.construct","title":"<code>construct(**parameters)</code>","text":"<p>Create a distribution from an explicit set of parameters.</p> <p>Parameters:</p> Name Type Description Default <code>**parameters</code> <code>ArrayLike</code> <p>Parameters that define a member of this family, passed as sequential arguments.</p> <code>{}</code> Source code in <code>src/causalprog/distribution/family.py</code> <pre><code>def construct(self, **parameters: ArrayLike) -&gt; Distribution:\n    \"\"\"\n    Create a distribution from an explicit set of parameters.\n\n    Args:\n        **parameters (ArrayLike): Parameters that define a member of this family,\n            passed as sequential arguments.\n\n    \"\"\"\n    return self._member(**parameters)\n</code></pre>"},{"location":"api/#causalprog.distribution.normal","title":"<code>normal</code>","text":"<p>(Multivariate) normal distribution, implemented via <code>jax.random</code> backend.</p>"},{"location":"api/#causalprog.distribution.normal.Normal","title":"<code>Normal</code>","text":"<p>               Bases: <code>Distribution</code></p> <p>A (possibly multivaraiate) normal distribution, \\(\\mathcal{N}(\\mu, \\Sigma)\\).</p> <p>The normal distribution is parametrised by its (vector of) mean value(s) \\(\\mu\\) and (matrix of) covariate(s) \\(\\Sigma\\). These values must be supplied to an instance at upon construction, and can be accessed via the <code>mean</code> (\\(\\mu\\)) and <code>cov</code> (\\(\\Sigma\\)) attributes, respectively.</p> Source code in <code>src/causalprog/distribution/normal.py</code> <pre><code>class Normal(Distribution):\n    r\"\"\"\n    A (possibly multivaraiate) normal distribution, $\\mathcal{N}(\\mu, \\Sigma)$.\n\n    The normal distribution is parametrised by its (vector of) mean value(s) $\\mu$ and\n    (matrix of) covariate(s) $\\Sigma$. These values must be supplied to an instance at\n    upon construction, and can be accessed via the ``mean`` ($\\mu$) and ``cov``\n    ($\\Sigma$) attributes, respectively.\n\n    \"\"\"\n\n    _dist: _Normal\n\n    @property\n    def mean(self) -&gt; JaxArray:\n        r\"\"\"Mean of the distribution, $\\mu$.\"\"\"\n        return self._dist.mean\n\n    @property\n    def cov(self) -&gt; JaxArray:\n        r\"\"\"Covariate matrix of the distribution, $\\Sigma$.\"\"\"\n        return self._dist.cov\n\n    def __init__(self, mean: ArrayCompatible, cov: ArrayCompatible) -&gt; None:\n        r\"\"\"\n        Create a new normal distribution.\n\n        Args:\n            mean (ArrayCompatible): Vector of mean values, $\\mu$.\n            cov (ArrayCompatible): Matrix of covariates, $\\Sigma$.\n\n        \"\"\"\n        mean = jnp.atleast_1d(mean)\n        cov = jnp.atleast_2d(cov)\n        super().__init__(_Normal(mean, cov), label=f\"({mean.ndim}-dim) Normal\")\n</code></pre>"},{"location":"api/#causalprog.distribution.normal.Normal.cov","title":"<code>cov</code>  <code>property</code>","text":"<p>Covariate matrix of the distribution, \\(\\Sigma\\).</p>"},{"location":"api/#causalprog.distribution.normal.Normal.mean","title":"<code>mean</code>  <code>property</code>","text":"<p>Mean of the distribution, \\(\\mu\\).</p>"},{"location":"api/#causalprog.distribution.normal.Normal.__init__","title":"<code>__init__(mean, cov)</code>","text":"<p>Create a new normal distribution.</p> <p>Parameters:</p> Name Type Description Default <code>mean</code> <code>ArrayCompatible</code> <p>Vector of mean values, \\(\\mu\\).</p> required <code>cov</code> <code>ArrayCompatible</code> <p>Matrix of covariates, \\(\\Sigma\\).</p> required Source code in <code>src/causalprog/distribution/normal.py</code> <pre><code>def __init__(self, mean: ArrayCompatible, cov: ArrayCompatible) -&gt; None:\n    r\"\"\"\n    Create a new normal distribution.\n\n    Args:\n        mean (ArrayCompatible): Vector of mean values, $\\mu$.\n        cov (ArrayCompatible): Matrix of covariates, $\\Sigma$.\n\n    \"\"\"\n    mean = jnp.atleast_1d(mean)\n    cov = jnp.atleast_2d(cov)\n    super().__init__(_Normal(mean, cov), label=f\"({mean.ndim}-dim) Normal\")\n</code></pre>"},{"location":"api/#causalprog.distribution.normal.NormalFamily","title":"<code>NormalFamily</code>","text":"<p>               Bases: <code>DistributionFamily</code></p> <p>Constructor class for (possibly multivariate) normal distributions.</p> <p>The multivariate normal distribution is parametrised by a (vector of) mean values \\(\\mu\\), and (matrix of) covariates \\(\\Sigma\\). A <code>NormalFamily</code> represents this family of distributions, \\(\\mathcal{N}(\\mu, \\Sigma)\\). The <code>.construct</code> method can be used to construct a <code>Normal</code> distribution with a fixed mean and covariate matrix.</p> Source code in <code>src/causalprog/distribution/normal.py</code> <pre><code>class NormalFamily(DistributionFamily):\n    r\"\"\"\n    Constructor class for (possibly multivariate) normal distributions.\n\n    The multivariate normal distribution is parametrised by a (vector of) mean values\n    $\\mu$, and (matrix of) covariates $\\Sigma$. A ``NormalFamily`` represents this\n    family of distributions, $\\mathcal{N}(\\mu, \\Sigma)$. The ``.construct`` method can\n    be used to construct a ``Normal`` distribution with a fixed mean and covariate\n    matrix.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Create a family of normal distributions.\"\"\"\n        super().__init__(Normal, family_name=\"Normal\")\n\n    def construct(self, mean: ArrayCompatible, cov: ArrayCompatible) -&gt; Normal:  # type: ignore # noqa: PGH003\n        r\"\"\"\n        Construct a normal distribution with the given mean and covariates.\n\n        Args:\n            mean (ArrayCompatible): Vector of mean values, $\\mu$.\n            cov (ArrayCompatible): Matrix of covariates, $\\Sigma$.\n\n        \"\"\"\n        return super().construct(mean=mean, cov=cov)\n</code></pre>"},{"location":"api/#causalprog.distribution.normal.NormalFamily.__init__","title":"<code>__init__()</code>","text":"<p>Create a family of normal distributions.</p> Source code in <code>src/causalprog/distribution/normal.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Create a family of normal distributions.\"\"\"\n    super().__init__(Normal, family_name=\"Normal\")\n</code></pre>"},{"location":"api/#causalprog.distribution.normal.NormalFamily.construct","title":"<code>construct(mean, cov)</code>","text":"<p>Construct a normal distribution with the given mean and covariates.</p> <p>Parameters:</p> Name Type Description Default <code>mean</code> <code>ArrayCompatible</code> <p>Vector of mean values, \\(\\mu\\).</p> required <code>cov</code> <code>ArrayCompatible</code> <p>Matrix of covariates, \\(\\Sigma\\).</p> required Source code in <code>src/causalprog/distribution/normal.py</code> <pre><code>def construct(self, mean: ArrayCompatible, cov: ArrayCompatible) -&gt; Normal:  # type: ignore # noqa: PGH003\n    r\"\"\"\n    Construct a normal distribution with the given mean and covariates.\n\n    Args:\n        mean (ArrayCompatible): Vector of mean values, $\\mu$.\n        cov (ArrayCompatible): Matrix of covariates, $\\Sigma$.\n\n    \"\"\"\n    return super().construct(mean=mean, cov=cov)\n</code></pre>"},{"location":"api/#causalprog.graph","title":"<code>graph</code>","text":"<p>Creation and storage of graphs.</p>"},{"location":"api/#causalprog.graph.graph","title":"<code>graph</code>","text":"<p>Graph storage.</p>"},{"location":"api/#causalprog.graph.graph.Graph","title":"<code>Graph</code>","text":"<p>               Bases: <code>Labelled</code></p> <p>A directed acyclic graph that represents a causality tree.</p> Source code in <code>src/causalprog/graph/graph.py</code> <pre><code>class Graph(Labelled):\n    \"\"\"A directed acyclic graph that represents a causality tree.\"\"\"\n\n    _nodes_by_label: dict[str, Node]\n\n    def __init__(self, label: str) -&gt; None:\n        \"\"\"Create end empty graph.\"\"\"\n        super().__init__(label=label)\n        self._graph = nx.DiGraph()\n        self._nodes_by_label = {}\n\n    def get_node(self, label: str) -&gt; Node:\n        \"\"\"Get a node from its label.\"\"\"\n        node = self._nodes_by_label.get(label, None)\n        if not node:\n            msg = f'Node not found with label \"{label}\"'\n            raise KeyError(msg)\n        return node\n\n    def add_node(self, node: Node) -&gt; None:\n        \"\"\"Add a node to the graph.\"\"\"\n        if node.label in self._nodes_by_label:\n            msg = f\"Duplicate node label: {node.label}\"\n            raise ValueError(msg)\n        self._nodes_by_label[node.label] = node\n        self._graph.add_node(node)\n\n    def add_edge(self, first_node: Node | str, second_node: Node | str) -&gt; None:\n        \"\"\"\n        Add an edge to the graph.\n\n        Adding an edge between nodes not currently in the graph,\n        will cause said nodes to be added to the graph along with\n        the edge.\n        \"\"\"\n        if isinstance(first_node, str):\n            first_node = self.get_node(first_node)\n        if isinstance(second_node, str):\n            second_node = self.get_node(second_node)\n        if first_node.label not in self._nodes_by_label:\n            self.add_node(first_node)\n        if second_node.label not in self._nodes_by_label:\n            self.add_node(second_node)\n        for node_to_check in (first_node, second_node):\n            if node_to_check != self._nodes_by_label[node_to_check.label]:\n                msg = \"Invalid node: {node_to_check}\"\n                raise ValueError(msg)\n        self._graph.add_edge(first_node, second_node)\n\n    def set_parameters(self, **parameter_values: float | None) -&gt; None:\n        \"\"\"\n        Set the current value of all given parameter nodes to the new values.\n\n        Parameter nodes are identified by variable name. Absent parameters retain their\n        current value. Names that correspond to nodes which are not parameter nodes\n        raise `TypeError`s.\n        \"\"\"\n        for name, new_value in parameter_values.items():\n            node = self.get_node(name)\n            if not isinstance(node, ParameterNode):\n                msg = f\"Node {name} is not a parameter node.\"\n                raise TypeError(msg)\n            node.value = new_value\n\n    @property\n    def parameter_nodes(self) -&gt; tuple[ParameterNode, ...]:\n        \"\"\"\n        Returns all parameter nodes in the graph.\n\n        The returned tuple uses the `ordered_nodes` property to obtain the parameter\n        nodes so that a natural \"fixed order\" is given to the parameters. When parameter\n        values are given as inputs to the causal estimand and / or constraint functions,\n        they will ideally be given as a single vector of parameter values, in which case\n        a fixed ordering for the parameters is necessary to make an association to the\n        components of the given input vector.\n        \"\"\"\n        return tuple(node for node in self.ordered_nodes if node.is_parameter)\n\n    @property\n    def predecessors(self) -&gt; dict[Node, Node]:\n        \"\"\"Get predecessors of every node.\"\"\"\n        return nx.algorithms.dfs_predecessors(self._graph)\n\n    @property\n    def successors(self) -&gt; dict[Node, list[Node]]:\n        \"\"\"Get successors of every node.\"\"\"\n        return nx.algorithms.dfs_successors(self._graph)\n\n    @property\n    def outcome(self) -&gt; Node:\n        \"\"\"The outcome node of the graph.\"\"\"\n        outcomes = [node for node in self.nodes if node.is_outcome]\n        if len(outcomes) == 0:\n            msg = \"Cannot create graph with no outcome nodes\"\n            raise ValueError(msg)\n        if len(outcomes) &gt; 1:\n            msg = \"Cannot yet create graph with multiple outcome nodes\"\n            raise ValueError(msg)\n        return outcomes[0]\n\n    @property\n    def nodes(self) -&gt; list[Node]:\n        \"\"\"The nodes of the graph.\"\"\"\n        return list(self._graph.nodes())\n\n    @property\n    def ordered_nodes(self) -&gt; list[Node]:\n        \"\"\"Nodes ordered so that each node appears after its dependencies.\"\"\"\n        if not nx.is_directed_acyclic_graph(self._graph):\n            msg = \"Graph is not acyclic.\"\n            raise RuntimeError(msg)\n        return list(nx.topological_sort(self._graph))\n\n    def roots_down_to_outcome(\n        self,\n        outcome_node_label: str,\n    ) -&gt; list[Node]:\n        \"\"\"\n        Get ordered list of nodes that outcome depends on.\n\n        Nodes are ordered so that each node appears after its dependencies.\n        \"\"\"\n        outcome = self.get_node(outcome_node_label)\n        ancestors = nx.ancestors(self._graph, outcome)\n        return [\n            node for node in self.ordered_nodes if node == outcome or node in ancestors\n        ]\n</code></pre>"},{"location":"api/#causalprog.graph.graph.Graph.nodes","title":"<code>nodes</code>  <code>property</code>","text":"<p>The nodes of the graph.</p>"},{"location":"api/#causalprog.graph.graph.Graph.ordered_nodes","title":"<code>ordered_nodes</code>  <code>property</code>","text":"<p>Nodes ordered so that each node appears after its dependencies.</p>"},{"location":"api/#causalprog.graph.graph.Graph.outcome","title":"<code>outcome</code>  <code>property</code>","text":"<p>The outcome node of the graph.</p>"},{"location":"api/#causalprog.graph.graph.Graph.parameter_nodes","title":"<code>parameter_nodes</code>  <code>property</code>","text":"<p>Returns all parameter nodes in the graph.</p> <p>The returned tuple uses the <code>ordered_nodes</code> property to obtain the parameter nodes so that a natural \"fixed order\" is given to the parameters. When parameter values are given as inputs to the causal estimand and / or constraint functions, they will ideally be given as a single vector of parameter values, in which case a fixed ordering for the parameters is necessary to make an association to the components of the given input vector.</p>"},{"location":"api/#causalprog.graph.graph.Graph.predecessors","title":"<code>predecessors</code>  <code>property</code>","text":"<p>Get predecessors of every node.</p>"},{"location":"api/#causalprog.graph.graph.Graph.successors","title":"<code>successors</code>  <code>property</code>","text":"<p>Get successors of every node.</p>"},{"location":"api/#causalprog.graph.graph.Graph.__init__","title":"<code>__init__(label)</code>","text":"<p>Create end empty graph.</p> Source code in <code>src/causalprog/graph/graph.py</code> <pre><code>def __init__(self, label: str) -&gt; None:\n    \"\"\"Create end empty graph.\"\"\"\n    super().__init__(label=label)\n    self._graph = nx.DiGraph()\n    self._nodes_by_label = {}\n</code></pre>"},{"location":"api/#causalprog.graph.graph.Graph.add_edge","title":"<code>add_edge(first_node, second_node)</code>","text":"<p>Add an edge to the graph.</p> <p>Adding an edge between nodes not currently in the graph, will cause said nodes to be added to the graph along with the edge.</p> Source code in <code>src/causalprog/graph/graph.py</code> <pre><code>def add_edge(self, first_node: Node | str, second_node: Node | str) -&gt; None:\n    \"\"\"\n    Add an edge to the graph.\n\n    Adding an edge between nodes not currently in the graph,\n    will cause said nodes to be added to the graph along with\n    the edge.\n    \"\"\"\n    if isinstance(first_node, str):\n        first_node = self.get_node(first_node)\n    if isinstance(second_node, str):\n        second_node = self.get_node(second_node)\n    if first_node.label not in self._nodes_by_label:\n        self.add_node(first_node)\n    if second_node.label not in self._nodes_by_label:\n        self.add_node(second_node)\n    for node_to_check in (first_node, second_node):\n        if node_to_check != self._nodes_by_label[node_to_check.label]:\n            msg = \"Invalid node: {node_to_check}\"\n            raise ValueError(msg)\n    self._graph.add_edge(first_node, second_node)\n</code></pre>"},{"location":"api/#causalprog.graph.graph.Graph.add_node","title":"<code>add_node(node)</code>","text":"<p>Add a node to the graph.</p> Source code in <code>src/causalprog/graph/graph.py</code> <pre><code>def add_node(self, node: Node) -&gt; None:\n    \"\"\"Add a node to the graph.\"\"\"\n    if node.label in self._nodes_by_label:\n        msg = f\"Duplicate node label: {node.label}\"\n        raise ValueError(msg)\n    self._nodes_by_label[node.label] = node\n    self._graph.add_node(node)\n</code></pre>"},{"location":"api/#causalprog.graph.graph.Graph.get_node","title":"<code>get_node(label)</code>","text":"<p>Get a node from its label.</p> Source code in <code>src/causalprog/graph/graph.py</code> <pre><code>def get_node(self, label: str) -&gt; Node:\n    \"\"\"Get a node from its label.\"\"\"\n    node = self._nodes_by_label.get(label, None)\n    if not node:\n        msg = f'Node not found with label \"{label}\"'\n        raise KeyError(msg)\n    return node\n</code></pre>"},{"location":"api/#causalprog.graph.graph.Graph.roots_down_to_outcome","title":"<code>roots_down_to_outcome(outcome_node_label)</code>","text":"<p>Get ordered list of nodes that outcome depends on.</p> <p>Nodes are ordered so that each node appears after its dependencies.</p> Source code in <code>src/causalprog/graph/graph.py</code> <pre><code>def roots_down_to_outcome(\n    self,\n    outcome_node_label: str,\n) -&gt; list[Node]:\n    \"\"\"\n    Get ordered list of nodes that outcome depends on.\n\n    Nodes are ordered so that each node appears after its dependencies.\n    \"\"\"\n    outcome = self.get_node(outcome_node_label)\n    ancestors = nx.ancestors(self._graph, outcome)\n    return [\n        node for node in self.ordered_nodes if node == outcome or node in ancestors\n    ]\n</code></pre>"},{"location":"api/#causalprog.graph.graph.Graph.set_parameters","title":"<code>set_parameters(**parameter_values)</code>","text":"<p>Set the current value of all given parameter nodes to the new values.</p> <p>Parameter nodes are identified by variable name. Absent parameters retain their current value. Names that correspond to nodes which are not parameter nodes raise <code>TypeError</code>s.</p> Source code in <code>src/causalprog/graph/graph.py</code> <pre><code>def set_parameters(self, **parameter_values: float | None) -&gt; None:\n    \"\"\"\n    Set the current value of all given parameter nodes to the new values.\n\n    Parameter nodes are identified by variable name. Absent parameters retain their\n    current value. Names that correspond to nodes which are not parameter nodes\n    raise `TypeError`s.\n    \"\"\"\n    for name, new_value in parameter_values.items():\n        node = self.get_node(name)\n        if not isinstance(node, ParameterNode):\n            msg = f\"Node {name} is not a parameter node.\"\n            raise TypeError(msg)\n        node.value = new_value\n</code></pre>"},{"location":"api/#causalprog.graph.node","title":"<code>node</code>","text":"<p>Graph nodes.</p>"},{"location":"api/#causalprog.graph.node.DistributionNode","title":"<code>DistributionNode</code>","text":"<p>               Bases: <code>Node</code></p> <p>A node containing a distribution.</p> Source code in <code>src/causalprog/graph/node.py</code> <pre><code>class DistributionNode(Node):\n    \"\"\"A node containing a distribution.\"\"\"\n\n    def __init__(\n        self,\n        distribution: DistributionFamily,\n        label: str,\n        *,\n        parameters: dict[str, str] | None = None,\n        constant_parameters: dict[str, float] | None = None,\n        is_outcome: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialise.\"\"\"\n        self._dist = distribution\n        self._constant_parameters = constant_parameters if constant_parameters else {}\n        self._parameters = parameters if parameters else {}\n        super().__init__(label, is_outcome=is_outcome, is_parameter=False)\n\n    def sample(\n        self,\n        sampled_dependencies: dict[str, npt.NDArray[float]],\n        samples: int,\n        rng_key: jax.Array,\n    ) -&gt; npt.NDArray[float]:\n        \"\"\"Sample a value from the node.\"\"\"\n        if not self._parameters:\n            concrete_dist = self._dist.construct(**self._constant_parameters)\n            return concrete_dist.sample(rng_key, samples)\n        output = np.zeros(samples)\n        new_key = jax.random.split(rng_key, samples)\n        for sample in range(samples):\n            parameters = {\n                i: sampled_dependencies[j][sample] for i, j in self._parameters.items()\n            }\n            concrete_dist = self._dist.construct(\n                **parameters, **self._constant_parameters\n            )\n            output[sample] = concrete_dist.sample(new_key[sample], 1)[0][0]\n        return output\n\n    def __repr__(self) -&gt; str:\n        return f'DistributionNode(\"{self.label}\")'\n</code></pre>"},{"location":"api/#causalprog.graph.node.DistributionNode.__init__","title":"<code>__init__(distribution, label, *, parameters=None, constant_parameters=None, is_outcome=False)</code>","text":"<p>Initialise.</p> Source code in <code>src/causalprog/graph/node.py</code> <pre><code>def __init__(\n    self,\n    distribution: DistributionFamily,\n    label: str,\n    *,\n    parameters: dict[str, str] | None = None,\n    constant_parameters: dict[str, float] | None = None,\n    is_outcome: bool = False,\n) -&gt; None:\n    \"\"\"Initialise.\"\"\"\n    self._dist = distribution\n    self._constant_parameters = constant_parameters if constant_parameters else {}\n    self._parameters = parameters if parameters else {}\n    super().__init__(label, is_outcome=is_outcome, is_parameter=False)\n</code></pre>"},{"location":"api/#causalprog.graph.node.DistributionNode.sample","title":"<code>sample(sampled_dependencies, samples, rng_key)</code>","text":"<p>Sample a value from the node.</p> Source code in <code>src/causalprog/graph/node.py</code> <pre><code>def sample(\n    self,\n    sampled_dependencies: dict[str, npt.NDArray[float]],\n    samples: int,\n    rng_key: jax.Array,\n) -&gt; npt.NDArray[float]:\n    \"\"\"Sample a value from the node.\"\"\"\n    if not self._parameters:\n        concrete_dist = self._dist.construct(**self._constant_parameters)\n        return concrete_dist.sample(rng_key, samples)\n    output = np.zeros(samples)\n    new_key = jax.random.split(rng_key, samples)\n    for sample in range(samples):\n        parameters = {\n            i: sampled_dependencies[j][sample] for i, j in self._parameters.items()\n        }\n        concrete_dist = self._dist.construct(\n            **parameters, **self._constant_parameters\n        )\n        output[sample] = concrete_dist.sample(new_key[sample], 1)[0][0]\n    return output\n</code></pre>"},{"location":"api/#causalprog.graph.node.Node","title":"<code>Node</code>","text":"<p>               Bases: <code>Labelled</code></p> <p>An abstract node in a graph.</p> Source code in <code>src/causalprog/graph/node.py</code> <pre><code>class Node(Labelled):\n    \"\"\"An abstract node in a graph.\"\"\"\n\n    def __init__(\n        self,\n        label: str,\n        *,\n        is_outcome: bool = False,\n        is_parameter: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialise.\"\"\"\n        super().__init__(label=label)\n        self._is_outcome = is_outcome\n        self._is_parameter = is_parameter\n\n    @abstractmethod\n    def sample(\n        self,\n        sampled_dependencies: dict[str, npt.NDArray[float]],\n        samples: int,\n        rng_key: jax.Array,\n    ) -&gt; float:\n        \"\"\"Sample a value from the node.\"\"\"\n\n    @property\n    def is_outcome(self) -&gt; bool:\n        \"\"\"Identify if the node is an outcome.\"\"\"\n        return self._is_outcome\n\n    @property\n    def is_parameter(self) -&gt; bool:\n        \"\"\"Identify if the node is a parameter.\"\"\"\n        return self._is_parameter\n</code></pre>"},{"location":"api/#causalprog.graph.node.Node.is_outcome","title":"<code>is_outcome</code>  <code>property</code>","text":"<p>Identify if the node is an outcome.</p>"},{"location":"api/#causalprog.graph.node.Node.is_parameter","title":"<code>is_parameter</code>  <code>property</code>","text":"<p>Identify if the node is a parameter.</p>"},{"location":"api/#causalprog.graph.node.Node.__init__","title":"<code>__init__(label, *, is_outcome=False, is_parameter=False)</code>","text":"<p>Initialise.</p> Source code in <code>src/causalprog/graph/node.py</code> <pre><code>def __init__(\n    self,\n    label: str,\n    *,\n    is_outcome: bool = False,\n    is_parameter: bool = False,\n) -&gt; None:\n    \"\"\"Initialise.\"\"\"\n    super().__init__(label=label)\n    self._is_outcome = is_outcome\n    self._is_parameter = is_parameter\n</code></pre>"},{"location":"api/#causalprog.graph.node.Node.sample","title":"<code>sample(sampled_dependencies, samples, rng_key)</code>  <code>abstractmethod</code>","text":"<p>Sample a value from the node.</p> Source code in <code>src/causalprog/graph/node.py</code> <pre><code>@abstractmethod\ndef sample(\n    self,\n    sampled_dependencies: dict[str, npt.NDArray[float]],\n    samples: int,\n    rng_key: jax.Array,\n) -&gt; float:\n    \"\"\"Sample a value from the node.\"\"\"\n</code></pre>"},{"location":"api/#causalprog.graph.node.ParameterNode","title":"<code>ParameterNode</code>","text":"<p>               Bases: <code>Node</code></p> <p>A node containing a parameter.</p> <p><code>ParameterNode</code>s differ from <code>DistributionNode</code>s in that they do not have an attached distribution (family), but rather represent a parameter that contributes to the shape of one (or more) <code>DistributionNode</code>s.</p> <p>The collection of parameters described by <code>ParameterNode</code>s forms the set of variables that will be optimised over in the corresponding <code>CausalProblem</code>. <code>ParameterNode</code>s have a <code>.value</code> attribute which stores the current value of the parameter to facilitate this - a <code>CausalProblem</code> needs to be able to update the values of the parameters so it can make evaluations of the causal estimand and constraints functions, as if they were functions of the parameters, rather than the <code>DistributionNode</code>s.</p> <p><code>ParameterNode</code>s should not be used to encode constant values used by <code>DistributionNode</code>s. Such constant values should be given to the necessary <code>DistributionNode</code>s directly as <code>constant_parameters</code>.</p> Source code in <code>src/causalprog/graph/node.py</code> <pre><code>class ParameterNode(Node):\n    \"\"\"\n    A node containing a parameter.\n\n    `ParameterNode`s differ from `DistributionNode`s in that they do not have an\n    attached distribution (family), but rather represent a parameter that contributes\n    to the shape of one (or more) `DistributionNode`s.\n\n    The collection of parameters described by `ParameterNode`s forms the set of\n    variables that will be optimised over in the corresponding `CausalProblem`.\n    `ParameterNode`s have a `.value` attribute which stores the current value\n    of the parameter to facilitate this - a `CausalProblem` needs to be able to\n    update the values of the parameters so it can make evaluations of the causal\n    estimand and constraints functions, _as if_ they were functions of the parameters,\n    rather than the `DistributionNode`s.\n\n    `ParameterNode`s should not be used to encode constant values used by\n    `DistributionNode`s. Such constant values should be given to the necessary\n    `DistributionNode`s directly as `constant_parameters`.\n    \"\"\"\n\n    def __init__(\n        self, label: str, *, value: float | None = None, is_outcome: bool = False\n    ) -&gt; None:\n        \"\"\"Initialise.\"\"\"\n        super().__init__(label, is_outcome=is_outcome, is_parameter=True)\n        self.value = value\n\n    def sample(\n        self,\n        sampled_dependencies: dict[str, npt.NDArray[float]],  # noqa: ARG002\n        samples: int,\n        rng_key: jax.Array,  # noqa: ARG002\n    ) -&gt; npt.NDArray[float]:\n        \"\"\"Sample a value from the node.\"\"\"\n        if self.value is None:\n            msg = f\"Cannot sample undetermined parameter node: {self.label}.\"\n            raise ValueError(msg)\n        return np.full(samples, self.value)\n\n    def __repr__(self) -&gt; str:\n        return f'ParameterNode(\"{self.label}\")'\n</code></pre>"},{"location":"api/#causalprog.graph.node.ParameterNode.__init__","title":"<code>__init__(label, *, value=None, is_outcome=False)</code>","text":"<p>Initialise.</p> Source code in <code>src/causalprog/graph/node.py</code> <pre><code>def __init__(\n    self, label: str, *, value: float | None = None, is_outcome: bool = False\n) -&gt; None:\n    \"\"\"Initialise.\"\"\"\n    super().__init__(label, is_outcome=is_outcome, is_parameter=True)\n    self.value = value\n</code></pre>"},{"location":"api/#causalprog.graph.node.ParameterNode.sample","title":"<code>sample(sampled_dependencies, samples, rng_key)</code>","text":"<p>Sample a value from the node.</p> Source code in <code>src/causalprog/graph/node.py</code> <pre><code>def sample(\n    self,\n    sampled_dependencies: dict[str, npt.NDArray[float]],  # noqa: ARG002\n    samples: int,\n    rng_key: jax.Array,  # noqa: ARG002\n) -&gt; npt.NDArray[float]:\n    \"\"\"Sample a value from the node.\"\"\"\n    if self.value is None:\n        msg = f\"Cannot sample undetermined parameter node: {self.label}.\"\n        raise ValueError(msg)\n    return np.full(samples, self.value)\n</code></pre>"},{"location":"api/#causalprog.utils","title":"<code>utils</code>","text":"<p>Utility classes and methods.</p>"},{"location":"api/#causalprog.utils.translator","title":"<code>translator</code>","text":"<p>Helper class to keep the codebase backend-agnostic.</p> <p>Our frontend (or user-facing) classes each use a syntax that applies across the package codebase. By contrast, the various backends that we want to support will have different syntaxes and call signatures for the functions that we want to support. As such, we need a helper class that can store this \"translation\" information, allowing the user to interact with the package in a standard way but also allowing them to choose their own backend if desired.</p>"},{"location":"api/#causalprog.utils.translator.Translator","title":"<code>Translator</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Maps syntax of a backend function to our frontend syntax.</p> <p>Different backends have different syntax for drawing samples from the distributions they support. In order to map these different syntaxes to our backend-agnostic framework, we need a container class to map the names we have chosen for our frontend methods to those used by their corresponding backend method.</p> <p>A <code>Translator</code> allows us to identify whether a user-provided backend object is compatible with one of our frontend wrapper classes (and thus, call signatures). It also allows users to write their own translators for any custom backends that we do not explicitly support.</p> <p>The use case for a <code>Translator</code> is as follows. Suppose that we have a frontend class <code>C</code> that needs to provide a method <code>do_something</code>. <code>C</code> stores a reference to a backend object <code>obj</code> that can provide the functionality of <code>do_something</code> via one of its methods, <code>obj.backend_method</code>. However, there is no guarantee that the signature of <code>do_something</code> maps identically to that of <code>obj.backend_method</code>. A <code>Translator</code> allows us to encode a mapping of <code>obj.backend_method</code>s arguments to those of <code>do_something</code>.</p> Source code in <code>src/causalprog/utils/translator.py</code> <pre><code>class Translator(ABC):\n    \"\"\"\n    Maps syntax of a backend function to our frontend syntax.\n\n    Different backends have different syntax for drawing samples from the distributions\n    they support. In order to map these different syntaxes to our backend-agnostic\n    framework, we need a container class to map the names we have chosen for our\n    frontend methods to those used by their corresponding backend method.\n\n    A ``Translator`` allows us to identify whether a user-provided backend object is\n    compatible with one of our frontend wrapper classes (and thus, call signatures). It\n    also allows users to write their own translators for any custom backends that we do\n    not explicitly support.\n\n    The use case for a ``Translator`` is as follows. Suppose that we have a frontend\n    class ``C`` that needs to provide a method ``do_something``. ``C`` stores a\n    reference to a backend object ``obj`` that can provide the functionality of\n    ``do_something`` via one of its methods, ``obj.backend_method``. However, there is\n    no guarantee that the signature of ``do_something`` maps identically to that of\n    ``obj.backend_method``. A ``Translator`` allows us to encode a mapping of\n    ``obj.backend_method``s arguments to those of ``do_something``.\n    \"\"\"\n\n    backend_method: str\n    corresponding_backend_arg: dict[str, str]\n\n    @property\n    @abstractmethod\n    def _frontend_method(self) -&gt; str:\n        \"\"\"Name of the frontend method that the backend is to be translated into.\"\"\"\n\n    @property\n    @abstractmethod\n    def compulsory_frontend_args(self) -&gt; set[str]:\n        \"\"\"Arguments that are required by the frontend function.\"\"\"\n\n    @property\n    def compulsory_backend_args(self) -&gt; set[str]:\n        \"\"\"Arguments that are required to be taken by the backend function.\"\"\"\n        return {\n            self.corresponding_backend_arg[arg_name]\n            for arg_name in self.compulsory_frontend_args\n        }\n\n    def __init__(\n        self, backend_method: str | None = None, **front_args_to_back_args: str\n    ) -&gt; None:\n        \"\"\"\n        Create a new Translator.\n\n        Args:\n            backend_method (str): Name of the backend method that the instance\n                translates.\n            **front_args_to_back_args (str): Mapping of frontend argument names to the\n                corresponding backend argument names.\n\n        \"\"\"\n        # Assume backend name is identical to frontend name if not provided explicitly\n        self.backend_method = (\n            backend_method if backend_method else self._frontend_method\n        )\n\n        # This should really be immutable after we fill defaults!\n        self.corresponding_backend_arg = dict(front_args_to_back_args)\n        # Assume compulsory frontend args that are not given translations\n        # retain their name in the backend.\n        for arg in self.compulsory_frontend_args:\n            if arg not in self.corresponding_backend_arg:\n                self.corresponding_backend_arg[arg] = arg\n\n    def translate_args(self, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ANN401\n        \"\"\"\n        Translate frontend arguments (with values) to backend arguments.\n\n        Essentially transforms frontend keyword arguments into their backend keyword\n        arguments, preserving the value assigned to each argument.\n        \"\"\"\n        return {\n            self.corresponding_backend_arg[arg_name]: arg_value\n            for arg_name, arg_value in kwargs.items()\n        }\n\n    def validate_compatible(self, obj: object) -&gt; None:\n        \"\"\"\n        Determine if ``obj`` provides a compatible backend method.\n\n        ``obj`` must provide a callable whose name matches ``self.backend_method``,\n        and the callable referenced must take arguments matching the names specified in\n        ``self.compulsory_backend_args``.\n\n        Args:\n            obj (object): Object to check possesses a method that can be translated into\n                frontend syntax.\n\n        \"\"\"\n        # Check that obj does provide a method of matching name\n        if not hasattr(obj, self.backend_method):\n            msg = f\"{obj} has no method '{self.backend_method}'.\"\n            raise AttributeError(msg)\n        if not callable(getattr(obj, self.backend_method)):\n            msg = f\"'{self.backend_method}' attribute of {obj} is not callable.\"\n            raise TypeError(msg)\n\n        # Check that this method will be callable with the information given.\n        method_params = inspect.signature(getattr(obj, self.backend_method)).parameters\n        # The arguments that will be passed are actually taken by the method.\n        for compulsory_arg in self.compulsory_backend_args:\n            if compulsory_arg not in method_params:\n                msg = (\n                    f\"'{self.backend_method}' does not \"\n                    f\"take argument '{compulsory_arg}'.\"\n                )\n                raise TypeError(msg)\n        # The method does not _require_ any additional arguments\n        method_requires = {\n            name for name, p in method_params.items() if p.default is p.empty\n        }\n        if not method_requires.issubset(self.compulsory_backend_args):\n            args_not_accounted_for = method_requires - self.compulsory_backend_args\n            raise TypeError(\n                f\"'{self.backend_method}' not provided compulsory arguments \"\n                \"(missing \" + \", \".join(args_not_accounted_for) + \")\"\n            )\n</code></pre>"},{"location":"api/#causalprog.utils.translator.Translator.compulsory_backend_args","title":"<code>compulsory_backend_args</code>  <code>property</code>","text":"<p>Arguments that are required to be taken by the backend function.</p>"},{"location":"api/#causalprog.utils.translator.Translator.compulsory_frontend_args","title":"<code>compulsory_frontend_args</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Arguments that are required by the frontend function.</p>"},{"location":"api/#causalprog.utils.translator.Translator.__init__","title":"<code>__init__(backend_method=None, **front_args_to_back_args)</code>","text":"<p>Create a new Translator.</p> <p>Parameters:</p> Name Type Description Default <code>backend_method</code> <code>str</code> <p>Name of the backend method that the instance translates.</p> <code>None</code> <code>**front_args_to_back_args</code> <code>str</code> <p>Mapping of frontend argument names to the corresponding backend argument names.</p> <code>{}</code> Source code in <code>src/causalprog/utils/translator.py</code> <pre><code>def __init__(\n    self, backend_method: str | None = None, **front_args_to_back_args: str\n) -&gt; None:\n    \"\"\"\n    Create a new Translator.\n\n    Args:\n        backend_method (str): Name of the backend method that the instance\n            translates.\n        **front_args_to_back_args (str): Mapping of frontend argument names to the\n            corresponding backend argument names.\n\n    \"\"\"\n    # Assume backend name is identical to frontend name if not provided explicitly\n    self.backend_method = (\n        backend_method if backend_method else self._frontend_method\n    )\n\n    # This should really be immutable after we fill defaults!\n    self.corresponding_backend_arg = dict(front_args_to_back_args)\n    # Assume compulsory frontend args that are not given translations\n    # retain their name in the backend.\n    for arg in self.compulsory_frontend_args:\n        if arg not in self.corresponding_backend_arg:\n            self.corresponding_backend_arg[arg] = arg\n</code></pre>"},{"location":"api/#causalprog.utils.translator.Translator.translate_args","title":"<code>translate_args(**kwargs)</code>","text":"<p>Translate frontend arguments (with values) to backend arguments.</p> <p>Essentially transforms frontend keyword arguments into their backend keyword arguments, preserving the value assigned to each argument.</p> Source code in <code>src/causalprog/utils/translator.py</code> <pre><code>def translate_args(self, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ANN401\n    \"\"\"\n    Translate frontend arguments (with values) to backend arguments.\n\n    Essentially transforms frontend keyword arguments into their backend keyword\n    arguments, preserving the value assigned to each argument.\n    \"\"\"\n    return {\n        self.corresponding_backend_arg[arg_name]: arg_value\n        for arg_name, arg_value in kwargs.items()\n    }\n</code></pre>"},{"location":"api/#causalprog.utils.translator.Translator.validate_compatible","title":"<code>validate_compatible(obj)</code>","text":"<p>Determine if <code>obj</code> provides a compatible backend method.</p> <p><code>obj</code> must provide a callable whose name matches <code>self.backend_method</code>, and the callable referenced must take arguments matching the names specified in <code>self.compulsory_backend_args</code>.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>Object to check possesses a method that can be translated into frontend syntax.</p> required Source code in <code>src/causalprog/utils/translator.py</code> <pre><code>def validate_compatible(self, obj: object) -&gt; None:\n    \"\"\"\n    Determine if ``obj`` provides a compatible backend method.\n\n    ``obj`` must provide a callable whose name matches ``self.backend_method``,\n    and the callable referenced must take arguments matching the names specified in\n    ``self.compulsory_backend_args``.\n\n    Args:\n        obj (object): Object to check possesses a method that can be translated into\n            frontend syntax.\n\n    \"\"\"\n    # Check that obj does provide a method of matching name\n    if not hasattr(obj, self.backend_method):\n        msg = f\"{obj} has no method '{self.backend_method}'.\"\n        raise AttributeError(msg)\n    if not callable(getattr(obj, self.backend_method)):\n        msg = f\"'{self.backend_method}' attribute of {obj} is not callable.\"\n        raise TypeError(msg)\n\n    # Check that this method will be callable with the information given.\n    method_params = inspect.signature(getattr(obj, self.backend_method)).parameters\n    # The arguments that will be passed are actually taken by the method.\n    for compulsory_arg in self.compulsory_backend_args:\n        if compulsory_arg not in method_params:\n            msg = (\n                f\"'{self.backend_method}' does not \"\n                f\"take argument '{compulsory_arg}'.\"\n            )\n            raise TypeError(msg)\n    # The method does not _require_ any additional arguments\n    method_requires = {\n        name for name, p in method_params.items() if p.default is p.empty\n    }\n    if not method_requires.issubset(self.compulsory_backend_args):\n        args_not_accounted_for = method_requires - self.compulsory_backend_args\n        raise TypeError(\n            f\"'{self.backend_method}' not provided compulsory arguments \"\n            \"(missing \" + \", \".join(args_not_accounted_for) + \")\"\n        )\n</code></pre>"},{"location":"theory/mathematical-context/","title":"Causal Problems and <code>causalprog</code>","text":"<p>TL;DR, <code>causalprog</code> solves</p> \\[ \\max_{\\Theta} / \\min_{\\Theta} \\sigma(\\Theta), \\quad \\text{subject to } \\quad \\mathrm{dist}(\\phi_\\mathrm{data}, \\phi_\\mathrm{model}(\\Theta))\\leq \\epsilon, \\] <p>given</p> <ul> <li>a (parametrised) causal model \\(\\Theta\\),</li> <li>a causal estimand \\(\\sigma\\),</li> </ul> <p>and matching constraints \\(\\phi = (\\phi_j)\\), where;</p> <ul> <li>\\(\\phi_\\mathrm{data}\\) is empirically observed values of \\(\\phi\\),</li> <li>\\(\\phi_\\mathrm{model}\\) is the analytical estimate of \\(\\phi\\) given \\(\\Theta\\),</li> <li>\\(\\mathrm{dist}\\) is a non-negative valued distance function (such as a suitable norm),</li> <li>a tolerance parameter \\(\\epsilon\\).</li> </ul>"},{"location":"theory/mathematical-context/#causal-problems","title":"Causal Problems","text":"<p>In full generality, we can describe a causal problem as follows.</p> <p>Let \\(X_1, X_2, ..., X_I\\) ( \\(I\\in\\mathbb{N}\\) ) be a collection of random variables. For each \\(i\\), let \\(V_i \\subset {1, ..., i-1}\\) be the (possibly empty) collection of the indices of the random variables that \\(X_i\\) is dependant upon. Note that we are assuming (WLOG) that the random variables are indexed somewhat sequentially in terms of causality / dependency.</p> <p>The structure imposed by the \\(V_i\\) allows for the relationships between the \\(X_i\\) to be realised as a DAG (Directed Acyclic Graph). The nodes represent the random variables \\(X_i\\), and as such we use the notation \\(X_i\\) interchangeably when referring to the random variables or nodes of the associated DAG. An edge directed into \\(X_i\\) from \\(X_k\\) (where \\((k &lt; i)\\)) encodes that the distribution of \\(X_i\\) depends on \\(X_k\\).</p> <p>Let \\(D_i = \\otimes_{k\\in V_i} X_k\\) and for each \\(X_i\\). Assume there exists a function \\(f_{X_i}\\), deterministic in its arguments, and with \\(\\mathrm{dom}(f_{x_i}) = D_i\\), such that \\(X_i \\sim f_{X_i}\\). That is to say, for each \\(i\\) there is some deterministic function \\(f_{X_i}\\) such that, given realisations of \\(X_k, k\\in V_i\\), \\(f_{X_i}\\) fully describes the distribution of \\(X_i\\). We will refer to the \\(f_{X_i}\\) as the structural equation of \\(X_i\\). The (parametrised) causal model is then \\(\\Theta := \\left\\{ f_{X_i} \\right\\}_{i\\leq n}\\).</p>"},{"location":"theory/mathematical-context/#further-parametrisations-of-theta","title":"Further Parametrisations of \\(\\Theta\\)","text":"<p>A causal model \\(\\Theta\\) is parametrised by the structural equations, which themselves may be further parametrised. In such a case, it is convenient to view the parametrisation of the structural equations as the parametrisation of \\(\\Theta\\).</p> <p>For example, in equation (1), Padh et. al., the structural equations are expressed as an expansion of (fixed) basis functions \\(\\left\\{\\psi_{i, j}\\right\\}_{i\\leq I, j\\leq J}\\), \\(J\\in\\mathbb{N}\\):</p> \\[ f_{X_i} = \\sum_{j=1}^{J} \\theta_{X_i}^{(j)}\\psi_{i_j}. \\] <p>Each \\(f_{X_i}\\) is thus fully described in terms of their coefficients \\(\\theta_{X_i} := (\\theta_{X_i}^{(j)})_{j\\leq J}\\). In such a case it is suitable to directly parametrise \\(\\Theta = \\left\\{\\theta_{X_i}\\right\\}_{i\\leq I}\\) rather than in terms of \\(f_{X_i}\\).</p>"},{"location":"theory/mathematical-context/#causal-estimands","title":"Causal Estimands","text":"<p>Next, let \\(\\sigma\\) be a causal estimand of interest; that is to say, some quantity to be calculated from \\(\\Theta\\), so \\(\\sigma = \\sigma(\\Theta)\\). This could be something like the expectation or variance of one of the random variables \\(X_k\\), for example.</p> <p>For the time being, <code>causalprog</code> focuses on casual estimands that are predominantly integrals of some type. In particular, the focus is on causal estimands that are the expectations (or possibly higher moments) of one of the random variables \\(X_k\\) given some other conditions. As such, computing the value of a causal estimand will be done largely through Monte Carlo sampling to approximate these integrands. Since no assumption is made on the dimensionality of our random variables (and thus domains of the integrals), some of these integrals may require a large number of samples before giving a suitable approximation to the true value.</p>"},{"location":"theory/mathematical-context/#the-mathrmdo-operator","title":"The \\(\\mathrm{do}\\) Operator","text":"<p>One particular estimand of interest is the effect of do-ing something, described by the \\(\\mathrm{do}\\) operator. The expected value of \\(X_k\\) given that we \"do\" \\(X_l = x^*\\) is written as \\(\\mathbb{E}[ X_k \\vert \\mathrm{do}(X_l = x^*) ]\\). In general, this is different from \\(\\mathbb{E}[ X_k \\vert X_l = x^* ]\\).</p> <p>However, the \\(\\mathrm{do}\\) operator has a relatively simple-to-explain effect on \\(\\Theta\\); essentially replace (the function) \\(f_{X_l}\\) with the constant \\(x^*\\) (or the appropriate mathematical object it defines).</p> <p>In the simple case where we have a random variable \\(Y\\) which depends on \\(X\\) (which we can control or fix) and \\(U\\) (which we cannot control), we have that</p> \\[\\mathbb{E}[ Y \\vert \\mathrm{do}(X = x^*) ] = \\int f_{Y}(x^*, u) \\ \\mathrm{d}u \\\\ \\approx \\frac{1}{M} \\sum_{i=1}^M f_Y(x^*, u^{(i)}),\\] <p>with the approximation following from a Monte Carlo estimation of the integrand using samples \\(u^{(i)}\\) drawn from \\(U\\).</p>"},{"location":"theory/mathematical-context/#matching-constraints","title":"Matching Constraints","text":"<p>The matching constraints \\(\\phi\\) are observable quantities that ensure the theoretical model remains representative of our empirical observations. When bounds for causal estimands are a concern, they serve to restrict the space of admissible causal models and thus tighten the obtainable bounds.</p> <p>In general \\(\\phi = (\\phi_k)_{k\\leq K}\\), \\(K\\in\\mathbb{N}\\) is a \\(K\\)-dimensional vector of matching constraints \\(\\phi_k\\). The quantities described in each \\(\\phi_k\\) can be empirically observed to give some data vector \\(\\phi_{\\mathrm{data}}\\), and estimated from a causal model \\(\\Theta\\) to give the theoretical values of these observables \\(\\phi_{\\mathrm{model}} = \\phi_{\\mathrm{model}}(\\Theta)\\).</p> <p>A common set of \\(\\phi_k\\) are moment-matching constraints of the form</p> \\[ \\phi_{i, 0} = \\mathbb{E}[X_i], \\quad \\phi_{i,j} = \\mathbb{E}[X_i X_j], \\] <p>for the observable random variables \\(X_i\\) (note that we can map the \\((i,j)\\)-indexing to a single index \\(k\\)).</p> <p>To attempt to infer the underlying causal model from observed data \\(\\phi_{\\mathrm{data}}\\), one would have to examine the set of causal models for which \\(\\phi_{\\mathrm{data}} = \\phi_{\\mathrm{model}}\\). In practice, we are typically concerned with those causal models that are \"close to\" \\(\\phi_{\\mathrm{data}}\\), rather than exactly equal, due to measurement inaccuracies or computational limitations. As such, one may provide a suitable distance function \\(\\mathrm{dist}\\) and tolerance parameter \\(\\epsilon\\). \\(\\mathrm{dist}(\\phi_{\\mathrm{data}}, \\phi_{\\mathrm{model}})\\) is interpreted as a quantification of the difference between the observed and expected constraint values, with a value of 0 indicating equality.</p> \\[\\mathrm{dist}(\\phi_{\\mathrm{data}}, \\phi_{\\mathrm{model}}) = \\vert\\vert \\phi_{\\mathrm{data}} - \\phi_{\\mathrm{model}} \\vert\\vert^2_{L^2} \\] <p>would be such an example.</p>"},{"location":"theory/mathematical-context/#bounds-for-causal-estimands","title":"Bounds for Causal Estimands","text":"<p>Given a causal estimand \\(\\sigma\\), it is natural to ask whether we can provide bounds for \\(\\sigma\\) given some empirical observations of (observable variables of) \\(\\Theta\\).</p> <p>To obtain suitable bounds on \\(\\sigma\\), and using the notation introduced in the sections above, we must solving the following (pair of) optimization problem(s):</p> \\[ \\max_\\Theta / \\min_\\Theta \\sigma(\\Theta), \\quad \\text{subject to } \\mathrm{dist}\\left(\\phi_\\mathrm{data} - \\phi_\\mathrm{model}(\\Theta) \\right) \\leq \\epsilon, \\] <p>Solving for the minimum provides the lower bound for \\(\\sigma\\), and solving for the maximum the upper bound. The corresponding argument-min \\(\\Theta_{\\mathrm{min}}\\) (respectively argument-max \\(\\Theta_{\\mathrm{max}}\\)) are the realisable causal models (IE the causal models that are consistent with our empirical observations up to the given tolerance) that attain the bounds of \\(\\sigma\\).</p> <p>Such problems can be tackled using approaches based on Lagrangian multipliers, for example, seeking the saddle points of the augmented lagrangian</p> \\[ \\mathcal{L}(\\Theta, \\lambda) := \\sigma(\\Theta) - \\lambda \\left( \\mathrm{dist}\\left(\\phi_\\mathrm{data} - \\phi_\\mathrm{model}(\\Theta) \\right)- \\epsilon\\right), \\] <p>and then determining whether they are maxima or minima.</p>"},{"location":"theory/simple-working-example/","title":"First steps: simple working example","text":"<p>As a starting point for the package, we will focus on implementing the required functionality to solve the simplified problem detailed below. During the description, we will highlight areas that will need to be designed with further generality in mind. Once the simplified example is working and tested, we will begin relaxing the assumptions that reduced us to the simplified problem - both mathematically and programmatically - and gradually expand the scope of the package outwards, from this basis.</p>"},{"location":"theory/simple-working-example/#problem-statement","title":"Problem Statement","text":"<p>We take two random variables \\(X\\) and \\(Y\\) with the following structural equations;</p> \\[ f_X = \\mathcal{N}(\\mu_X, \\nu_X^2), \\quad f_Y = \\mathcal{N}(X, \\nu_Y^2), \\] <p>where we will assume, for the time being, that \\(\\nu_X, \\nu_Y \\in [0,\\infty)\\) are fixed values, and \\(\\mu_X\\) is a parameter in our causal model. This means that the causal model, \\(\\Theta = \\{\\mu_X\\}\\) has only one parameter for the time being.</p> <p>Our causal estimand of interest will simply be the expectation of our \"outcome\" variable \\(Y\\);</p> \\[ \\sigma = \\mathbb{E}[Y]. \\] <p>Our constraints will be the observed mean of \\(X\\), \\(\\phi = \\mathbb{E}[X]\\), and we will take our distance function to be \\(\\mathrm{dist}(\\phi, \\psi) = \\vert \\phi - \\psi \\vert\\) (essentially a 1-dimensional \\(L^2\\)-norm). For a given tolerance \\(\\epsilon\\), we thus have the following problem to solve;</p> \\[ \\max_{\\mu_X} / \\min_{\\mu_X} \\mathbb{E}[Y], \\quad\\text{subject to}\\quad \\vert \\phi_{\\mathrm{data}} - \\mathbb{E}[X] \\vert \\leq \\epsilon. \\] <p>By the structural equations, we can infer that \\(\\mathbb{E}[Y] = \\mathbb{E}[X] = \\mu_X\\), thus reaching</p> \\[ \\max_{\\mu_X} / \\min_{\\mu_X} \\mu_X, \\quad\\text{subject to}\\quad \\vert \\phi_{\\mathrm{data}} - \\mu_X \\vert \\leq \\epsilon. \\] <p>The solution to this problem is \\(\\mu_X = \\phi_\\mathrm{data} \\pm \\epsilon\\) (the positive solution corresponding to the maximisation).</p> <p>The purpose of solving this simple problem is that it will force us (as developers) to answer a number of structural questions about the package.</p>"},{"location":"theory/simple-working-example/#generalising","title":"Generalising","text":"<p>Once we have a working implementation of the above problem, we will begin generalising the problem above and expanding the functionality of the package to match. Some immediate ideas for generalisations are as follows:</p> <ul> <li>Generalise to multiple parameters. The example above could - in particular - have \\(\\nu_X\\) and \\(\\nu_Y\\) be parameters to the model too. This will require us to ensure that whatever general classes we have to represent the structural equations are broad enough to cope with arbitrarily-shaped parameters.</li> <li>A related task is to generalise the structural equations to other (non-normal) distributions first, and then on to more complex \"distributions\" like feed-forward networks.</li> <li>Generalise to multiple constraints. Immediate possibilities would be imposing constraints on the variance of \\(X\\) and/or \\(Y\\), particularly if we have already made \\(\\nu_X\\) and/or \\(\\nu_Y\\) parameters themselves (rather than fixed values).</li> <li>Generalise to arbitrary distance functions. This is likely some low-hanging fruit at first, but has the potential to be quite complex if we later want to use functionality like \"auto-diff\" to speed up solving the optimisation problem.</li> <li>Generalising to arbitrary causal estimates.</li> <li>Though not particularly general, having a method or function that applies the \\(\\mathrm{do}\\) operator would be of interest beyond just use in a causal estimand. Though for the time being, we might only want it to be applicable to root nodes.</li> </ul>"}]}